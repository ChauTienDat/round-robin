#include <iostream>
#include <vector>
#include <queue>
#include <iomanip>
#include <algorithm>
#include <fstream>
#include <string>
#include <set> 
#include <limits> 
#include <sstream> 

using namespace std;

// ======================= Cấu trúc dữ liệu =======================
struct TienTrinh {
    int ma = -1;
    int den = 0; // AT
    int tongXuLy = 0; // BT
    int doUuTien = 0; // Priority (P) - ĐƯỢC ĐỌC NHƯNG BỊ BỎ QUA TRONG LOGIC LẬP LỊCH

    int conLai = 0;
    int xuLyDaXong = 0;

    int batDauLanDau = -1;
    int hoanThanh = 0;
    int quayVong = 0;
    int cho = 0;
    int phanHoi = 0;

    int thoiDiemVaoRQ = -1;
    int tongThoiGianChoChiTiet = 0;
    string waitingTimeDetails;
};

// =================== Round Robin (FCFS) Logic ===================
struct Gantt {
    int batDau, ketThuc;
    int pid;
};

template<typename T>
void xuat(ofstream& fout, const T& val) {
    cout << val;
    fout << val;
}

int main() {
    ifstream fin("input.txt");
    ofstream fout("output.txt");

    // [Error handling omitted for brevity]

    int n;
    if (!(fin >> n) || n <= 0) return 1;
    vector<TienTrinh> ds(n);

    // ĐỌC 3 CỘT DỮ LIỆU TỪ INPUT (AT, BT, Priority)
    for (int i = 0; i < n; ++i) {
        ds[i].ma = i;
        if (!(fin >> ds[i].den >> ds[i].tongXuLy >> ds[i].doUuTien)) return 1;
        ds[i].conLai = ds[i].tongXuLy;
    }

    int quantum;
    if (!(fin >> quantum) || quantum <= 0) return 1;

    // Sắp xếp theo Arrival Time, sau đó theo PID (ma)
    sort(ds.begin(), ds.end(), [](const TienTrinh& a, const TienTrinh& b) {
        if (a.den != b.den) return a.den < b.den;
        return a.ma < b.ma;
        });

    // In input summary (dùng lại code trước đó để in đủ cột)
    xuat(fout, "So tien trinh: "); xuat(fout, n); xuat(fout, "\n");
    xuat(fout, "Quantum: "); xuat(fout, quantum); xuat(fout, "\n\n");
    xuat(fout, "===== Danh sach tien trinh (Priority IGNORED for scheduling) =====\n");
    xuat(fout, "+------------+--------------------+---------------+----------+\n");
    xuat(fout, "| Tien trinh | Thoi diem vao RL    | Thoi gian CPU | Do uu tien |\n");
    xuat(fout, "+------------+--------------------+---------------+----------+\n");
    for (auto& tt : ds) {
        cout << "| P" << left << setw(10) << tt.ma + 1 << "| " << setw(19) << tt.den
            << "| " << setw(14) << tt.tongXuLy << "| " << setw(9) << tt.doUuTien << "|\n";
        fout << "| P" << left << setw(10) << tt.ma + 1 << "| " << setw(19) << tt.den
            << "| " << setw(14) << tt.tongXuLy << "| " << setw(9) << tt.doUuTien << "|\n";
    }
    xuat(fout, "+------------+--------------------+---------------+----------+\n\n");


    // =================== Logic Round Robin (FCFS) ===================
    vector<TienTrinh> processes = ds;
    queue<int> ready_queue; // FCFS Queue
    set<int> in_ready_queue_set; // Kiểm soát trùng lặp

    int thoiGian = 0;
    int chiSo = 0;
    int daXong = 0;
    vector<Gantt> gantt;

    if (n > 0 && processes[0].den > 0) thoiGian = processes[0].den;

    auto push_to_ready_queue = [&](int p_idx, int event_time) {
        if (processes[p_idx].conLai > 0 && in_ready_queue_set.find(p_idx) == in_ready_queue_set.end()) {
            processes[p_idx].thoiDiemVaoRQ = event_time;
            ready_queue.push(p_idx); // FCFS: Push to back
            in_ready_queue_set.insert(p_idx);
        }
        };

    while (daXong < n) {

        // 1. Cập nhật Arrivals
        while (chiSo < n && processes[chiSo].den <= thoiGian) {
            push_to_ready_queue(chiSo, processes[chiSo].den);
            chiSo++;
        }

        // 2. Xử lý Idle / Time Jump
        if (ready_queue.empty()) {
            int next_event_time = (chiSo < n) ? processes[chiSo].den : -1;
            if (next_event_time != -1 && next_event_time > thoiGian) {
                gantt.push_back({ thoiGian, next_event_time, -1 });
                thoiGian = next_event_time;
                continue;
            }
            else if (next_event_time == -1 && daXong < n) {
                break;
            }
        }

        // 3. Thực thi CPU
        if (!ready_queue.empty()) {
            int hienTai = ready_queue.front(); // FCFS: Lấy phần tử đầu tiên
            ready_queue.pop();
            in_ready_queue_set.erase(hienTai);

            // Tính toán WT CHI TIẾT
            if (processes[hienTai].thoiDiemVaoRQ != -1) {
                int thoiDiemRaRQ = thoiGian;
                int khoangCho = thoiDiemRaRQ - processes[hienTai].thoiDiemVaoRQ;
                processes[hienTai].tongThoiGianChoChiTiet += khoangCho;
                stringstream ss;
                if (!processes[hienTai].waitingTimeDetails.empty()) ss << processes[hienTai].waitingTimeDetails << " + ";
                ss << "(" << thoiDiemRaRQ << "-" << processes[hienTai].thoiDiemVaoRQ << ")";
                processes[hienTai].waitingTimeDetails = ss.str();
                processes[hienTai].thoiDiemVaoRQ = -1;
            }

            // Thời gian chạy bằng Quantum hoặc thời gian còn lại
            int chay = min(quantum, processes[hienTai].conLai);
            int batDau = thoiGian;
            thoiGian += chay;
            processes[hienTai].conLai -= chay;
            processes[hienTai].xuLyDaXong += chay;

            if (processes[hienTai].batDauLanDau == -1) {
                processes[hienTai].batDauLanDau = batDau;
                processes[hienTai].phanHoi = processes[hienTai].batDauLanDau - processes[hienTai].den;
            }

            gantt.push_back({ batDau, thoiGian, processes[hienTai].ma + 1 });

            // 4. Cập nhật Arrivals xảy ra trong thời gian vừa chạy (Đảm bảo FCFS đúng)
            while (chiSo < n && processes[chiSo].den <= thoiGian) {
                push_to_ready_queue(chiSo, processes[chiSo].den);
                chiSo++;
            }

            if (processes[hienTai].conLai == 0) {
                processes[hienTai].hoanThanh = thoiGian;
                daXong++;
            }
            else {
                // Bị Preempt (hết quantum) -> Đưa lại vào cuối RQ
                push_to_ready_queue(hienTai, thoiGian);
            }
        }
    }

    // [Result display code omitted for brevity but should be included in final executable]

    // =================== Xuất Kết quả (đã tối giản) ===================
    vector<Gantt> merged_gantt;
    if (!gantt.empty()) {
        merged_gantt.push_back(gantt[0]);
        for (size_t i = 1; i < gantt.size(); ++i) {
            if (gantt[i].pid == merged_gantt.back().pid) merged_gantt.back().ketThuc = gantt[i].ketThuc;
            else merged_gantt.push_back(gantt[i]);
        }
    }

    xuat(fout, "===== Bieu do Gantt (CPU Time) =====\n");
    for (auto& g : merged_gantt) {
        int doDai = g.ketThuc - g.batDau;
        if (doDai <= 0) continue;
        if (g.pid == -1) {
            cout << "| Idle" << string(max(0, doDai * 2 - 4), ' ');
            fout << "| Idle" << string(max(0, doDai * 2 - 4), ' ');
        }
        else {
            cout << "| P" << g.pid << string(max(0, doDai * 2 - 2), ' ');
            fout << "| P" << g.pid << string(max(0, doDai * 2 - 2), ' ');
        }
    }
    cout << "|\n"; fout << "|\n";

    for (auto& g : merged_gantt) {
        int doDai = g.ketThuc - g.batDau;
        if (doDai <= 0) continue;
        cout << setw(2) << g.batDau << string(doDai * 2, ' ');
        fout << setw(2) << g.batDau << string(doDai * 2, ' ');
    }
    if (!merged_gantt.empty()) {
        cout << setw(2) << merged_gantt.back().ketThuc << "\n\n";
        fout << setw(2) << merged_gantt.back().ketThuc << "\n\n";
    }

    double tongTAT = 0, tongWT = 0;
    sort(processes.begin(), processes.end(), [](const TienTrinh& a, const TienTrinh& b) { return a.ma < b.ma; });

    xuat(fout, "===== Bang ket qua chi tiet =====\n");
    xuat(fout, "+------------+--------------------+---------------+----------+----------+------------+\n");
    xuat(fout, "| Tien trinh | Thoi diem vao RL    | Thoi gian CPU | Do uu tien | Bat dau  | Hoan thanh |\n");
    xuat(fout, "+------------+--------------------+---------------+----------+----------+------------+\n");

    const int W_PID = 12, W_DEN = 20, W_CPU = 15, W_PRIORITY = 10, W_BD = 10, W_HOAN = 12;

    for (auto& tt : processes) {
        int TAT = tt.hoanThanh - tt.den;
        int WT = tt.tongThoiGianChoChiTiet;
        tt.quayVong = TAT;
        tt.cho = WT;
        tongTAT += TAT;
        tongWT += WT;

        cout << "| P" << left << setw(W_PID - 2) << tt.ma + 1
            << "| " << setw(W_DEN - 1) << tt.den
            << "| " << setw(W_CPU - 1) << tt.tongXuLy
            << "| " << setw(W_PRIORITY - 1) << tt.doUuTien
            << "| " << setw(W_BD - 1) << tt.batDauLanDau
            << "| " << setw(W_HOAN - 1) << tt.hoanThanh
            << "|\n";

        fout << "| P" << left << setw(W_PID - 2) << tt.ma + 1
            << "| " << setw(W_DEN - 1) << tt.den
            << "| " << setw(W_CPU - 1) << tt.tongXuLy
            << "| " << setw(W_PRIORITY - 1) << tt.doUuTien
            << "| " << setw(W_BD - 1) << tt.batDauLanDau
            << "| " << setw(W_HOAN - 1) << tt.hoanThanh
            << "|\n";
    }
    xuat(fout, "+------------+--------------------+---------------+----------+----------+------------+\n");

    xuat(fout, "\n===== Chi tiet Thoi gian Cho (Waiting Time Details) =====\n");
    for (auto& tt : processes) {
        xuat(fout, "P"); xuat(fout, tt.ma + 1);
        xuat(fout, " = ");
        if (tt.waitingTimeDetails.empty()) {
            xuat(fout, "0");
        }
        else {
            xuat(fout, tt.waitingTimeDetails);
            xuat(fout, " = "); xuat(fout, tt.tongThoiGianChoChiTiet);
        }
        xuat(fout, "\n");
    }
    xuat(fout, "\n");

    cout << fixed << setprecision(2);
    fout << fixed << setprecision(2);

    xuat(fout, "\nTong TAT = "); xuat(fout, tongTAT);
    xuat(fout, "\nTong WT (Chi tiet) = "); xuat(fout, tongWT);
    xuat(fout, "\n- TAT trung binh = "); xuat(fout, (tongTAT / n));
    xuat(fout, "\n- WT trung binh (Chi tiet) = "); xuat(fout, (tongWT / n));
    xuat(fout, "\n");

    fin.close();
    fout.close();
    return 0;
}
